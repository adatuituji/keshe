/******************** (C) COPYRIGHT 2012 Robottime ********************
* 文件名    : main.c
* 作者       : 《深入浅出ARM7－LPC213x_214x(上)》
* 版本       : V1.0.0
* 日期       : 2012.3.28
* 所属产品 : 探索者ARM7 LPC2138主控制板
* 功能       : UART0串口通信库函数，FIFO方式接收1字节数据
* 接口/设备: 下载口接串行通信设备
********************************************************************/

#include "config.h"
#include "lib_irq.h"

/*设置串口通信波特率，使用探索者蓝牙模块时，需设为9600*/
#define UART_BPS 9600

/*   定义串口模式设置数据结构  */
typedef struct UartMode
{
	uint8 datab;  //字长度，5/6/7/8可选
	uint8 stopb;  //停止位，1/2可选
	uint8 parity; //奇偶效验位，0-无效验；1-奇效验；2-偶效验
}UARTMODE;

uint8 rcv_buf;          //FIFO数据接收缓冲区 
volatile uint8 rcv_new; //接收新数据标志


/**********************************************************************************************************
** 函数名称 ：UART0_Set
** 函数功能 ：串口模式设置
** 入口参数 ：baud          ： 波特率
                    UARTMODE ： 串口模式变量
** 返  回 值 ：1为设置成功，0为设置失败
**********************************************************************************************************/
int8 UART0_Set(uint32 baud, UARTMODE set)
{
	uint32 bak;
	
	/* 参数过滤 */
	if((baud==0)||(baud>115200)) return(0);
	if((set.datab<5)||(set.datab>8)) return(0);
	if(set.parity>4) return(0);
	
	/* 设置串口波特率 */
	U0LCR = 0x80;
	bak   = (Fpclk >> 4) / baud;
	U0DLM = bak >> 8;
	U0DLL = bak & 0XFF;
	
	/* 设置串口模式 */
	bak = set.datab - 5;
	if(set.stopb == 2) bak |= 0x04;
	
	if(set.parity != 0)
	{
		set.parity = set.parity - 1;
		bak |= 0x08;
	}
	
	/* 设置奇偶效验 */
	bak |= set.parity << 4;
	
	U0LCR = bak;
	
	return(1);
}


/**********************************************************************************************************
** 函数名称 ：UART0_Init
** 函数功能 ：串口初始化
** 入口参数 ：无
** 返  回 值 ：无
**********************************************************************************************************/
int8 UART0_Init()
{
	UARTMODE set;
	set.datab  = 8;
	set.stopb  = 1;
	set.parity = 0;
	
	PINSEL0 = (PINSEL0 & (~0X0F)) | 0x05;
	rcv_new = 0;

	UART0_Set(UART_BPS,set); //串口模式设置
	U0FCR = 0x01;              //使能FIFO，并设置出发点为1字节
	U0IER = 0x01;              //允许RBR中断，即接收中断
	
	IRQEnable();            //使能IRQ中断
	
	/* 使能UART0中断 */
	VICIntSelect = 0x00000000;        //设置所有通道为IRQ中断
	VICVectCntl0 = 0x20 | 0x06;       //UART0分配到IRQ slot0，即最高优先级
	VICVectAddr0= (uint32)IRQ_UART0; //设置UART0向量地址，即lib_irq.c里的“void __irq IRQ_UART0 (void)”函数
	VICIntEnable = 1 << 0x06;        //使能UART0中断
}


/**********************************************************************************************************
** 函数名称 ：UART0_SendByte
** 函数功能 ：向串口0发送1字节数据
** 入口参数 ：dat ：要发送的数据
** 返  回 值 ：无
**********************************************************************************************************/
void UART0_SendByte(uint8 dat)
{
	U0THR = dat;
	while((U0LSR & 0x40) == 0);
}


/**********************************************************************************************************
** 函数名称 ：UART0_GetBuf
** 函数功能 ：在串口中断中，接收1字节串口数据，并写入到局部变量rcv_buf中
** 入口参数 ：无
** 返  回 值 ：无
**********************************************************************************************************/
void UART0_GetBuf()
{
	if((U0IIR & 0x0f) == 0x04) rcv_buf = U0RBR;  //读取FIFO的数据，并清除中断
	VICVectAddr = 0x00;   //中断处理结束
}


/**********************************************************************************************************
** 函数名称 ：UART0_ReadBuf
** 函数功能 ：供其他函数调用当前接收的串口中断的数据
** 入口参数 ：无
** 返  回 值 ：接收的串口数据rcv_buf的值
**********************************************************************************************************/
uint8 UART0_ReadBuf()
{
	return(rcv_buf);
}

  
